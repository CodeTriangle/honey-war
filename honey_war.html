<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>Honey War simulator</title>
		<script src="honey_war.js"></script>
		<style>
			.movediv {
				display: inline-block;
				vertical-align: top;
			}
			.flex-container {
				display: flex;
				flex-wrap: wrap;
			}
			.flex-spacer {
				width: 1em;
			}
			#mp-settings {
				flex-direction: column;
			}
			.inset {
				border-style: inset none none inset;
				border-radius: .4em;
				padding: .5em;
				border-width: thin;
				background: #eeea;
				mix-blend-mode: multiply;
			}
			#legend td > img {
				width: 50px;
			}
			a {
				color: black;
				cursor: pointer;
			}
			h3 {
				margin-top: .5em;
				margin-bottom: .5em;
			}
			h4 {
				margin: 0;
			}
			input[disabled] {
			    filter: invert(25%);
			}
			input[disabled] * {
			    color: grey;
			}
			.move-item { }
			.move-item:hover, .move-item:active {
				text-decoration: underline;
				color: blue;
			}
			.button {
				width: max-content;
			}
			.verb {
				text-transform: capitalize;
			}
			.piece {
				text-transform: capitalize;
				font-weight: bold;
			}
			.win {
				text-transform: capitalize;
				font-style: italic;
			}
			.inline-icon {
				height: 1.2em;
				vertical-align: top;
			}
			.hidden-space {
				display: inline-block;
			}
		</style>
	</head>
	<body>
		<h1 id="turn"></h1>
		<div class="flex-container">
			<svg id="board" width="500" height="500"/>
			<div class="movediv">
				<h3>Possible Moves</h3>
				<button onclick="undo();">UNDO</button>
				<a id="moves_export">
					<button id="export" onclick="export_game()">EXPORT</button>
				</a>
				<button id="restore" disabled onclick="restore_game()">RESTORE</button>
				<div id="moves"></div>
			</div><div class="flex-spacer"></div>
			<div class="movediv" style="max-width: 550px;">
				<h3>Settings</h3>
				<div id="mp-settings" class="flex-container inset">
					<h3>Player Names</h3>
					<div class="inset">
						<span class="icon">1C</span>
						<input type="text" class="inline-input"
							id="P1-name" value="Player 1" onchange="update_players()">
						vs.
						<span class="icon">2C</span>
						<input type="text" class="inline-input"
							id="P2-name" value="Player 2" onchange="update_players()">
					</div>
					<h3>Game Settings</h3>
					<div class="inset">
						<div>
							<h4>Configuration:</h4>
							<input type="radio" name="boardconfig" id="configmirrored"
							value="mirrored" onchange="opt('mirrored')" checked>Mirrored</input>
							<input type="radio" name="boardconfig" id="configrotated"
							value="rotated" onchange="opt('rotated')">Rotated</input>
						</div>
						<div>
							<h4>Board diameter:</h4>
							<input type="radio" name="boardsize" id="boardlarge"
							value="large" onchange="opt('large')" checked>11 (Standard)</input>
							<input type="radio" name="boardsize" id="boardsmall"
							value="small" onchange="opt('small')" disabled>9 (Small, only two towers fit)</input>
						</div>
						<div>
							<h4><span class="icon">T</span><span class="piece">Tower</span> configuration:</h4>
							<input type="radio" name="towerconfig" id="towers3"
							value="3" onchange="opt('t3')" checked>3</input>
							<input type="radio" name="towerconfig" id="towers2"
							value="2" onchange="opt('t2')">2</input>
							<input type="radio" name="towerconfig" id="towers2w"
							value="2w" onchange="opt('t2w')">2, widely spaced</input>
						</div>
					</div>
					<h3>Rule variations</h3>
					<div class="inset">
						<div><span class="icon">1F</span><span class="piece">Footsoldier</span> mobility:</div>
						<div><input type="checkbox" id="friendly-footsoldiers"
						onchange="opt('friendly-footsoldiers')" checked disabled>
							Footsoldiers move through friendlies in phase 2.
						</input></div>
						<div><input type="checkbox" id="buff-footsoldiers"
						onchange="opt('buff-footsoldiers')" checked disabled>
							Footsoldiers can move backward.
						</input></div>
						<div><input type="checkbox" id="upgrade-footsoldiers"
						onchange="opt('upgrade-footsoldiers')" disabled>
							Footsoldiers become infantry on reaching the end of the
							board.
						</input></div>
						<div><input type="checkbox" id="stranded-footsoldiers"
						onchange="opt('stranged-footsoldiers')" disabled>
							Footsoldiers can attack the castle backward as a special case.
						</input></div>
					</div>
					<div class="inset">
						<div><span class="icon">1G</span><span class="piece">Garrison</span> range:</div>
						<div><input type="radio" name="garrisonrange" id="garrisonshort"
						value="garrisonshort" onchange="opt('garrisonshort')" checked disabled>
							Garrisons attack adjacent hexes.
						</input></div>
						<div><input type="radio" name="garrisonrange" id="garrisonlong"
						value="garrisonlong" onchange="opt('garrisonlong')" disabled>
							Garrisons attack at double range.
						</input></div>
						<div><input type="radio" name="garrisonrange" id="garrisonboth"
						value="garrisonboth" onchange="opt('garrisonboth')" disabled>
							Garrisons attack at standard and double range.
						</input></div>
					</div>
					<div class="inset">
						<div><span class="icon">1B</span><span class="piece">Trebuchet</span> attacks:</div>
						<div><input type="checkbox" id="buff-infantry"
						onchange="opt('buff-infantry')" disabled>
							Infantry survive bombardment as footsoldiers.
						</input></div>
					</div>
					<h3>Multiplayer</h3>
					<div class="inset">
						Session ID: <input type="text" id="sessionID">
						<button id="getNewSession">New</button>
					</div>
					<button id="reset" class="button" onclick="reset_game()">Apply and reset game</button>
				</div>
			</div>
		</div>
		<h3>Legend of Pieces</h3>
		<table id="legend">
			<tr>
				<td><img src="imgs/1F.svg"></td>
				<td><img src="imgs/2F.svg"></td>
				<td>Footsoldier</td>
			</tr>
			<tr>
				<td><img src="imgs/1I.svg"></td>
				<td><img src="imgs/2I.svg"></td>
				<td>Infantry</td>
			</tr>
			<tr>
				<td><img src="imgs/1K.svg"></td>
				<td><img src="imgs/2K.svg"></td>
				<td>Cavalry</td>
			</tr>
			<tr>
				<td><img src="imgs/1H.svg"></td>
				<td><img src="imgs/2H.svg"></td>
				<td>Chariot</td>
			</tr>
			<tr>
				<td><img src="imgs/1B.svg"></td>
				<td><img src="imgs/2B.svg"></td>
				<td>Trebuchet</td>
			</tr>
			<tr>
				<td><img src="imgs/1C.svg"></td>
				<td><img src="imgs/2C.svg"></td>
				<td>Castle</td>
			</tr>
			<tr>
				<td><img src="imgs/1G.svg"></td>
				<td><img src="imgs/2G.svg"></td>
				<td>Tower/Garrison</td>
			</tr>
		</table>
		<p>
			For rules and other information, please see <a href="https://sajemtan.miraheze.org/wiki/Honey_War">this page</a>.
		</p>
		<div>
			<button id="import_btn" onclick="import_game(false)">Import</button>
			<button id="replay_btn" onclick="import_game(true)">Replay</button>
			<br>
			<textarea id="input_area"></textarea>
		</div>
		<script>
			"use strict";
			const board_el = document.getElementById('board');
			const header_el = document.getElementById('turn');
			const move_list = document.getElementById('moves');
			const symbols = {
				tower: "T",
				footsoldier: "F",
				infantry: "I",
				trebuchet: "B",
				castle: "C",
				castle_damaged: "D",
				cavalry: "K",
				chariot: "H",
				garrison: "G",
				tower_infantry: "TI",
				tower_cavalry: "TC"
			};
			const enemy_of = [0, 2, 1];
			var turn = 1;
			var player = 1;
			var phase = 2;
			var moves = [];
			var undo_list = [];
			var current_move = 0;

			var opts = {
				board_size: "large",
				towers: "3",
				configuration: "rotated",
				rules: {
					fF: true,
					bF: true,
					uF: false,
					sF: false,
					Gr: "short"
				}
			};

			function set_opts() {
				if (document.getElementById('configrotated').checked) {
					opts.configuration = 'rotated';
				} else {
					document.getElementById('configmirrored').checked = true;
					opts.configuration = 'mirrored';
				}
				if (document.getElementById('boardsmall').checked) {
					opts.board_size = 'small';
				} else {
					document.getElementById('boardlarge').checked = true;
					opts.board_size = 'large';
				}
				if (document.getElementById('towers2').checked) {
					opts.towers = '2';
				} else if (document.getElementById('towers2w').checked) {
					opts.towers = '2w';
				} else {
					document.getElementById('towers3').checked = true;
					opts.towers = '3';
				}
				console.dir(opts);
			}
			set_opts();

			var board = make_board();

			var players = {1: "Player 1", 2: "Player 2"};

			function encode(s) {
				return s.replace(/./g, function(c) {
					return"&#"+c.charCodeAt(0)+";"
				});
			}

			function update_players() {
				players[1] = encode(document.getElementById("P1-name").value);
				players[2] = encode(document.getElementById("P2-name").value);
				write_title();
			}
			function format_player(player) {
				return icon_for("castle", player) + '<text>' + players[player] + '</text>';
			}
			function draw_icons() {
				for (let el of document.getElementsByClassName("icon")) {
					const name = el.innerHTML;
					el.innerHTML = '<img class="inline-icon" src="imgs/' + name + '.svg" />';
				}
			}
			draw_icons();

			function write_title() {
				header_el.innerHTML = "Turn " + turn
					+ ", " + format_player(player)
					+ ", Phase " + phase;
			}
			function setup_turn() {
				draw_board(board_el, board);
				write_title();
				moves = list_possible_moves(board, player, (phase==2));
				display_moves(board, moves, move_list);
			}
			function undo() {
				if (turn == 1 && player == 1 && phase == 2) {
					return;
				} else if (phase == 2) {
					phase = 1;
				} else if (player == 2) {
					player = 1;
					phase = 2;
				} else {
					turn--;
					player = 2;
					phase = 2;
				}
				apply_move(board, undo_list[undo_list.length-1], true);
				current_move--;
				undo_list.pop();
				setup_turn();
			}
			function redo() {
				if (current_move < undo_list.length) {
					apply_move(board, moves[current_move]);
					current_move++;
					update();
				}
			}
			function execute(move_number) {
				apply_move(board, moves[move_number], false);
				undo_list.push(moves[move_number]);
				current_move++;
				update();
			}
			function update(move_number) {
				phase++;
				if (phase == 3) {
					phase = 1;
					player++;
					if (player == 3) {
						player = 1;
						turn++;
					}
				}
				setup_turn();
				if (undo_list[undo_list.length-1].verb == "win") {
					move_list.innerHTML = "Game Over";
				}
			}
			update_players();
			setup_turn();

			function download(text, name, type) {
			  var a = document.getElementById("moves_export");
			  var file = new Blob([text], {type: type});
			  a.href = URL.createObjectURL(file);
			  a.download = name;
			}
			function sleep(ms) {
			  return new Promise(resolve => setTimeout(resolve, ms));
			}

			function export_game() {
				download(JSON.stringify({
					playernames: {
						1: document.getElementById("P1-name").value,
						2: document.getElementById("P2-name").value
					},
					session: "",
					moveslist: undo_list,
					boardstate: board,
					options: opts
				}), 'Honey-War-Log.json', 'application/json');
			}
			var autoplay_timer;
			async function do_import_game(gamestate, slowmode) {
				let moveslist;
				if (gamestate instanceof Array) {
					moveslist = gamestate;
				} else {
					moveslist = gamestate.moveslist;
					if (gamestate.playernames) {
						document.getElementById("P1-name").value = gamestate.playernames[1];
						document.getElementById("P2-name").value = gamestate.playernames[2];
						update_players();
					}
				}
				for (const move of moveslist) {
					if (slowmode) {
						var locs = [];
						for (const k in move) {
							if (k != "verb") {
								locs.push(board[move[k].loc].id);
							}
						}
						highlight_spaces(locs);
						await sleep(1500);
					}
					apply_move(board, move, false);
					undo_list.push(move);
					update();
				}
			}
			function import_game(slowmode) {
				reset_game();
				const new_game = JSON.parse(document.getElementById("input_area").value);
				if (new_game) {
					do_import_game(new_game, slowmode);
				}
			}

			var stash = [];
			function stash_game() {
				stash.push({
					s_board: JSON.stringify(board),
					s_moves: undo_list,
					s_moves_avail: moves,
					s_move: current_move,

					s_player: player,
					s_turn: turn,
					s_phase: phase,

					s_options: opts
				});
			}

			async function reset_game() {
				stash_game();
				set_opts();
				board = make_board();
				player = 1;
				turn = 1;
				phase = 2;
				current_move = 0;
				undo_list = [];
				setup_turn();
				document.getElementById("restore").disabled = false;

			}
			async function restore_game() {
				const restore = stash[stash.length - 1];

				board = JSON.parse(restore.s_board);
				undo_list = restore.s_moves;
				moves = restore.s_moves_avail;
				player = restore.s_player;
				turn = restore.s_turn;
				phase = restore.s_phase;

				setup_turn();

				stash.pop();
				document.getElementById("restore").disabled = (stash.length > 0) ? false : true;

			}


		</script>
	</body>
</html>
